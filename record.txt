자료구조 순서
1. 자료구조 ADT 정의
2. 정의한 ADT 구현
3. 구현이 완료된 자료구조 활용

scanf 사용시 반환값 무시X
1. 앞에 (void) 붙이기
2. 변수 = scanf

c++11 char* 문제
1. const char* 로 변경
2. (char*)"문자열" 로 변경

23.12.19 시작
using namespace std 사용자제
순차탐색 알고리즘 시간복잡도 = n
이진탐색 알고리즘

23.12.21 2일차
재귀  
탈출조건 구성이 매우 중요
하노이타워
자료형 정의 = 정의 + 모든 관련 연산 종류 결정
추상자료형 = 기능이 무엇인지 나열한 것 = ADT

23.12.27 3일차
배열 기반 리스트

23.12.28 4일차
배열 기반 리스트
git 연동

24.01.01 5일차
연결리스트

24.01.02 6일차
단순 연결리스트 ADT 및 구현
함수포인터

24.01.03 7일차
단순 연결리스트 정렬

24.01.07 ex
파일 정리

24.01.08 8일차
원형 연결 리스트
양방향 연결 리스트1

24.01.14 9일차
양방향 연결 리스트2

24.01.16 10일차
스택

24.01.17 11일차
계산기 구현(중위 표기법 -> 후기 표기법 구현)

24.01.22 12일차
계산기 구현(후위 표기법 연산 구현 및 하위 함수 종합)

24.02.06 13일차
원형큐 구현
연결리스트 기반 큐 구현

24.02.13 14일차
큐 활용 시뮬레이션

24.02.18 15일차
덱 구현

24.02.19 16일차
이진트리 구현
이진트리 순회 구현
수식트리 헤드

24.02.20
수식트리 코드 구현


24.02.22
수식트리 계산 구현 / 중위표기법 소괄호 추가

24.02.25
우선순위 큐

24.02.26
힙

24.02.28
힙 계산 구현

24.03.06
쓸만한 힙 구현 = 우선순위 큐 구현

24.03.07
우선순위 큐 응용(문자열 길이 = 우선순위, 문자열 출력 프로그램)
버블정렬
선택정렬
삽입정렬
힙정렬
병합정렬

24.03.10
병합정렬 병합 구현
퀵 정렬 구현

24.03.11
퀵 정렬 오류 해결
퀵 정렬 피벗 바꾸기

24.03.13
기수정렬
보간탐색

24.03.14
이진탐색트리

24.03.17
이진탐색트리 데이터 저장 및 탐색 

24.03.18
이진탐색트리 데이터 삭제

24.03.20
이진탐색트리 데이터 삭제

24.03.21
이진탐색트리 데이터 삭제

24.03.24
이진탐색트리 단점-> 저장 순서에 따라 탐색성능에 큰 차이가 있다
AVL트리
LL, RR, LR, RL 회전을 활용한 트리의 균형 맞추기
균형인수 활용

24.03.26
AVL트리 회전 구현
AVL트리 리밸런스 구현


24.03.27
이진탐색트리 노드 삽입 수정
테이블 = 사전구조 = 맵(map)
해쉬함수 = 테이블에 의미를 부여

24.03.28
테이블 구현
좋은 해쉬 함수 = 충돌을 덜 일으키는 함수
해쉬함수 디자인 우선순위 = 키의 특성, 저장공간 크기
충돌 해결(선형 조사법: 충돌시 f(x)+1..~+n, 이차조사법: f(x)+n^2)
Delete 존재이유: 충돌 의심을 위해


24.03.31
이차해쉬 = 해쉬함수를 2개 구성, 다른 자리(주소) 찾기
체이닝 = 해당 자리(주소)를 연결리스트를 이용하여 자리 추가, 하나의 해쉬에 여러 슬롯
체이닝 구현
구현한 체이닝의 문제점: 슬롯의 밸류값을 무조건 포인터로 지정해야함
              ex) int값으로 지정시 삭제/탐색 시 마지막 반환 NULL을 0으로 인식할 수 있음

24.04.02
그래프
무방향 그래프
방향 그래프
완전 그래프(방향 그래프라면 무방향 그래프 간선 수의 2배)
가중치 그래프
부분 그래프
무방향 그래프 집합 표현
1) 정점 집합 V(G) = {A, B, C, D}
2) 간선 집합 E(G) = {(A, B), (A, D), (B, C)}

방향 그래프 집합 표현
간선 집합 이외 동일
ex) E(G) = {<A, C>, <B, C>, <D, A>}
<A, C> = A가 C를 가르키는 간선

그래프 구현 방법
1) 인접 행렬 기반
2) 인접 리스트 기반

24.04.03
인접 리스트 기반 그래프 구현
DFS 구현

24.04.07
DFS 구현 (스택 활용)
BFS 구현 (큐 활용)

최소비용 신장트리
단순 경로 = 간선중복x (중복기준 = 간선) ex) A-B-C-A == 단순경로,
사이클 = 단순경로 이면서 시작과 끝 정점이 같은 경로

신장 트리 = 사이클을 형성하지 않는 트리
1. 그래프의 모든 정점이 간선에 의해서 하나로 연결
2. 사이클 형성 X

최소신장트리 = 신장 트리의 모든 가중치 합이 최소인 그래프
 *사용 알고리즘
1. 크루스칼 알고리즘
가중치를 기준으로 간선을 정렬, MST가 될 때까지 간선을 하나씩 선택 및 삭제
2. 프림 알고리즘
하나의 정점을 시작으로 MST가 될 때까지 트리를 확장

24.04.08
크루스칼 알고리즘 이해

오름차순
1. 가중치를 기준, 간선을 오름차순 정렬
2. 낮은 가중치 간선부터 하나씩 그래프에 추가
3. 사이클 형성 간선은 추가하지 않음
4. 간선 수가 정점수보다 하나 적을 때 MST완성

내림차순
1. 가중치를 기준, 간선을 내림차순 정렬
2. 높은 가중치 간선부터 하나씩 그래프에서 제거
3. 두 정점을 연결하는 다른 경로가 없을 경우 간선 제거 X
4. 간선 수가 정점수보다 하나 적을 때 MST완성

24.04.09
크루스칼 알고리즘 완전 구현
1회독 완